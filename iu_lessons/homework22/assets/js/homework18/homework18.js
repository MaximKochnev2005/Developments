//Упражнение 1: let a='100px';letb='323px';letresult= ...console.log(result);
let a = '100px'; let b = '323px'; let result = parseInt(a) + parseInt(b); console.log(result);

//Упражнение 2: Напишите код, который выведет в консоль максимальное число среди указанных: 10, -45, 102, 36, 12, 0, -1
console.log(Math.max(10, -45, 102, 36, 12, 0, -1));

//Упражнение 3: Взять указанный ниже код и написать решение для каждого случая

let c = 123.3399; //Округлить до 123
console.log(Math.round(c));

let d = 0.111; //Округлить до 1
console.log(Math.ceil(d));

let e = 45.333333; //Округлить до 45.3
console.log(Math.floor(e * 10) / 10);

let f = 3; //Возвести в степень 5 (должно быть 243)
console.log(Math.pow(f, 5));

//let g = 400000000000000; //Записать в сокращенном виде
let g = 4e14;
console.log(g);

//let h = '1' != 1; //Поправить условие, чтобы результат был true (значения изменять нельзя, только оператор)
let h = '1' !== 1;
console.log(h);

//Упражнение 4: console.log(0.1 + 0.2 === 0.3); //Вернёт false, почему?
/* Такое поведение возникает из-за особенностей представления чисел с плавающей точкой.
Данные в памяти хранятся в виде двоичного кода. Многие дробные числа при переводе в двоичную систему счисления становятся бесконечной дробью.
Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа.
Проверить это можно переведя 0.1 в двоичную систему счисления и отбратно, получится 0.1000000000000000055511151231257827021181583404541015625.
Аналогично для 0.2: 0.200000000000000011102230246251565404236316680908203125 и для 0.3: 0.299999999999999988897769753748434595763683319091796875
Сумма 0.1000000000000000055511151231257827021181583404541015625 и 0.200000000000000011102230246251565404236316680908203125: 0.3000000000000000166533453693773481063544750213623046875, но ближайшее число, которое может хранится в памяти: 0.3000000000000000444089209850062616169452667236328125
Итог:
0.3000000000000000444089209850062616169452667236328125 !== 0.299999999999999988897769753748434595763683319091796875
*/